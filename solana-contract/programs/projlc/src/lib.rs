use anchor_lang::prelude::*;
use anchor_spl::{
	associated_token, associated_token::AssociatedToken,
	token::{self, Mint, TokenAccount, Token, TransferChecked}
};
pub const USDC_MINT: Pubkey = pubkey!("AN9roykAcQMHj7kDtdvWRvMUGNYaRmy8kz5SeX2bTuMt");
declare_id!("5H5Az3WbtrW52ZJdjvsgY1Gnzaorvsp1AFpf4oMz3W1S");

#[program]
pub mod letter_of_credit {
    	use super::*;
	// init global state
    	pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        	let state 		= &mut ctx.accounts.global_state;
		state.admin 		= ctx.accounts.admin.key();
		state.lc_counter 	= 0;
		state.bump		= ctx.bumps.global_state;
	        Ok(())
	}

	// creat an lc.
	// takes amount and deadline in unix timestamp
	// LC accounts are autogenerated as pda. seeds are lc, buyer key and global state current counter
	pub fn create_lc(ctx: Context<CreateLC>, amount: u64, deadline: u64)-> Result<()>{
		// require time exceeds time now
		require!(deadline > Clock::get()?.unix_timestamp.try_into().unwrap(), LCError::InvalidDeadline);
		// require amount is more than 0
		require!(amount > 0, LCError::InvalidAmount);

		// fetch newly init lc, buyer and global state from context
		// to not pass global state at idl call, derived with seed in Create LC context
		let lc = &mut ctx.accounts.letter_credit;
		let buyer = &ctx.accounts.buyer;
		let global_state = &mut ctx.accounts.global_state;

		// derive bump and index
		let index = global_state.lc_counter;
		// set lc variables
		lc.buyer = buyer.key();
	        lc.amount = amount;
        	lc.deadline = deadline;
	        lc.funded = false;
	        lc.released = false;
	        lc.refunded = false;
	        lc.seller = Pubkey::default();
		lc.index = index;
		lc.bump = ctx.bumps.letter_credit;
		
		// increment global state counter
		global_state.lc_counter = global_state.lc_counter.checked_add(1).unwrap();
		
		Ok(())
	}

	// register a seller to an LC. Seller receives funds when released by admin or buyer
	pub fn register_seller(ctx: Context<RegisterSeller>) -> Result<()>{
		let lc = &mut ctx.accounts.letter_credit;
		require!(lc.seller == Pubkey::default(), LCError::SellerAlreadyRegistered);
		lc.seller = ctx.accounts.seller.key();
		Ok(())
	}
	// fund lc account
	pub fn fund(ctx: Context<FundLC>)-> Result<()>{
		let lc = &mut ctx.accounts.letter_credit;
		let buyer = &ctx.accounts.buyer;
		let lc_token_account = &mut ctx.accounts.lc_token_account;
		let buyer_token_account = &mut ctx.accounts.buyer_token_account;
		let token_program = ctx.accounts.token_program.to_account_info();
		let decimals = ctx.accounts.mint.decimals;
		let amount: u64 = lc.amount * 10u64.pow(ctx.accounts.mint.decimals as u32);
		
		// validate buyer is lc buyer and lc is not funded
		require_keys_eq!(lc.buyer, buyer.key(), LCError::InvalidSenderForFund);
		require!(!lc.funded, LCError::AlreadyFunded);
		
		let cpi_accounts = TransferChecked{
			from: buyer_token_account.to_account_info(),
			to: lc_token_account.to_account_info(),
			authority : buyer.to_account_info(),
			mint:ctx.accounts.mint.to_account_info(),
		};
		let cpi_context = CpiContext::new(token_program, cpi_accounts);
		token::transfer_checked(cpi_context, amount, decimals)?;
		lc.funded = true;
		Ok(())
	}

	// release. can only be triggered by admin
	pub fn release(ctx: Context<Release>)-> Result<()>{
		let lc = &mut ctx.accounts.letter_credit;
		let sender = &ctx.accounts.admin;
		let global_state = &ctx.accounts.global_state;
		let seller_token_account = &mut ctx.accounts.seller_token_account;
		let lc_token_account = &mut ctx.accounts.lc_token_account;
		let mint = &ctx.accounts.mint;
		let seller = &ctx.accounts.seller;
		require_keys_eq!(lc.seller.key(), seller.key(), LCError::UnauthorizedRelease);

		require!(lc.seller != Pubkey::default(), LCError::SellerNotRegistered);
		require_keys_eq!(global_state.admin , sender.key(), LCError::UnauthorizedRelease);
		let now = Clock::get()?.unix_timestamp;
		require!(now >= 0 && (now as u64) <= lc.deadline, LCError::DealinePassed);


		lc.released = true;


		let lc_seeds: &[&[u8]] = &[
			b"lc",
			lc.buyer.as_ref(),
			&lc.index.to_le_bytes(),
			&[lc.bump],
		];

		lc_transfer_for_lc(
		        lc_token_account.to_account_info(),
		        seller_token_account.to_account_info(),
		        lc.to_account_info(),
		        mint.to_account_info(),
		        ctx.accounts.token_program.to_account_info(),
		        lc.amount,
		        mint.decimals,
			lc_seeds,	
		)?;

		Ok(())
		
	}
	
	pub fn refund(ctx: Context<Refund>)->Result<()>{
                let lc = &mut ctx.accounts.letter_credit;
                let sender = &ctx.accounts.sender;
                let global_state = &ctx.accounts.global_state;
                let buyer_token_account = &mut ctx.accounts.buyer_token_account;
                let lc_token_account = &mut ctx.accounts.lc_token_account;
                let mint = &ctx.accounts.mint;
		let now = Clock::get()?.unix_timestamp;

		if now >= 0 && now as u64 <= lc.deadline {
			require_keys_eq!(sender.key(), global_state.admin, LCError::UnauthorizedRefund);
		}else{
			require!(sender.key() == global_state.admin || sender.key() == lc.buyer, LCError::UnauthorizedRefund);
		}
		lc.refunded = true;
		let lc_seeds: &[&[u8]] = &[
			b"lc",
			lc.buyer.as_ref(),
			&lc.index.to_le_bytes(),
			&[lc.bump]
		];
		lc_transfer_for_lc(
                        lc_token_account.to_account_info(),
                        buyer_token_account.to_account_info(),
                        lc.to_account_info(),
                        mint.to_account_info(),
                        ctx.accounts.token_program.to_account_info(),
                        lc.amount,
                        mint.decimals,
                        lc_seeds,
		)?;
		Ok(())
	}
}

pub fn lc_transfer_for_lc<'info>(
		from:	AccountInfo<'info>,
		to:	AccountInfo<'info>,
		authority: AccountInfo<'info>,
		mint: AccountInfo<'info>,
    		token_program: AccountInfo<'info>,
    		amount: u64,
    		decimals: u8,
	    	seeds: &[&[u8]],	
	) -> Result<()>
	{
		let cpi_accounts = anchor_spl::token::TransferChecked {
			from,
        		to,
        		authority,
        		mint,
		};
		let seed_bind = [seeds];
		let amount_with_decimals: u64 = amount * 10u64.pow(decimals as u32);
		let cpi_ctx = CpiContext::new(token_program, cpi_accounts).with_signer(&seed_bind);
		token::transfer_checked(cpi_ctx, amount_with_decimals, decimals)?;
		Ok(())
}


#[derive(Accounts)]
pub struct Initialize<'info> {
	#[account(init, payer = admin, space = 8 + 32 + 8 + 1 , seeds = [b"global_state"], bump)]
	pub global_state:	Account<'info, GlobalState>,
	#[account(mut)]
	pub admin:		Signer<'info>,
	pub system_program:	Program<'info, System>,

}

#[derive(Accounts)]
pub struct CreateLC<'info> {
	#[account(init, payer = buyer, space = 8 + 64 + 16 + 3 + 9 , seeds = [b"lc", buyer.key().as_ref(), global_state.lc_counter.to_le_bytes().as_ref()], bump)]
	pub letter_credit: Account<'info, LetterCredit>,
	#[account(mut)]
	pub buyer: Signer<'info>,
	#[account(mut, seeds = [b"global_state"], bump)]
	pub global_state: Account<'info, GlobalState>,
	pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct RegisterSeller<'info>{
	#[account(mut)]
	pub seller: Signer<'info>,
	#[account(mut)]
	pub letter_credit: Account<'info, LetterCredit>,
}

#[derive(Accounts)]
pub struct FundLC<'info>{
	#[account(mut)]
	pub letter_credit: Account<'info, LetterCredit>,
	#[account(mut)]
	pub buyer: Signer<'info>,
	#[account(mut, associated_token::mint = mint, associated_token::authority = buyer)]
	pub buyer_token_account : Account<'info, TokenAccount>,
	#[account(init_if_needed, payer = buyer, associated_token::mint = mint, associated_token::authority = letter_credit)]	
	pub lc_token_account : Account<'info, TokenAccount>,
	pub associated_token_program: Program<'info, AssociatedToken>,
	#[account(constraint = mint.key() == USDC_MINT @ LCError::InvalidMint)]
	pub mint: Account<'info, Mint>,
	pub token_program: Program<'info, Token>,
	pub system_program: Program<'info, System>,
}


#[derive(Accounts)]
pub struct Release<'info> {
    #[account(mut)]
    pub admin: Signer<'info>,
    #[account(
        seeds = [b"global_state"],
	bump=global_state.bump
    )]
    pub global_state: Account<'info, GlobalState>,
    #[account(
        mut,
        constraint = letter_credit.funded @ LCError::LCNotFunded,
        constraint = !letter_credit.released @ LCError::LCAlreadyReleased,
        constraint = !letter_credit.refunded @ LCError::LCAlreadyRefunded,
    )]
    pub letter_credit: Account<'info, LetterCredit>,
    #[account(
        mut,
        associated_token::mint = mint,
        associated_token::authority = letter_credit
    )]
    pub lc_token_account: Account<'info, TokenAccount>,
    #[account(
	init_if_needed,
	payer = admin,
        associated_token::mint = mint,
        associated_token::authority = seller
    )]
    pub seller_token_account: Account<'info, TokenAccount>,
    /// CHECK:    
    pub seller: UncheckedAccount<'info>,
    #[account(constraint = mint.key() == USDC_MINT @ LCError::InvalidMint)]
    pub mint: Account<'info, Mint>,
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Refund<'info> {
    #[account(mut)]
    pub sender: Signer<'info>,
    #[account(
        seeds = [b"global_state"],
        bump = global_state.bump,
    )]
    pub global_state: Account<'info, GlobalState>,
    #[account(
        mut,
        constraint = letter_credit.funded @ LCError::LCNotFunded,
        constraint = !letter_credit.released @ LCError::LCAlreadyReleased,
        constraint = !letter_credit.refunded @ LCError::LCAlreadyRefunded,
    )]
    pub letter_credit: Account<'info, LetterCredit>,
    #[account(
        mut,
        associated_token::mint = mint,
        associated_token::authority = letter_credit
    )]
    pub lc_token_account: Account<'info, TokenAccount>,
    #[account(
        mut,
        associated_token::mint = mint,
        associated_token::authority = letter_credit.buyer
    )]
    pub buyer_token_account: Account<'info, TokenAccount>,
    #[account(constraint = mint.key() == USDC_MINT @ LCError::InvalidMint)]
    pub mint: Account<'info, Mint>,
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct LetterCredit {
	    pub buyer: Pubkey,
	    pub seller: Pubkey,
	    pub amount: u64,
	    pub deadline: u64,
	    pub funded: bool,
	    pub released: bool,
	    pub refunded: bool,
	    pub index:	u64,
	    pub bump:	u8
}
#[account]
pub struct GlobalState {
	pub admin: Pubkey,
	pub lc_counter : u64,
	pub bump: u8,
}

#[error_code]
pub enum LCError {
	#[msg("Invalid amount")]
	InvalidAmount,
	#[msg("Invalid deadline")]
	InvalidDeadline,
	#[msg("Seller already registered")]
	SellerAlreadyRegistered,
	#[msg("Only buyer can send this message")]
	InvalidSenderForFund,
	#[msg("Already funded")]
	AlreadyFunded,
	#[msg("LC not funded")]
    	LCNotFunded,
	#[msg("LC already released")]
    	LCAlreadyReleased,
    	#[msg("LC already refunded")]
    	LCAlreadyRefunded,
    	#[msg("Seller not registered")]
    	SellerNotRegistered,
    	#[msg("Unauthorized")]
    	UnauthorizedRelease,
    	#[msg("Deadline passed")]
    	DealinePassed,
	#[msg("Requirements for refund not met")]
	UnauthorizedRefund,
	#[msg("Mint address is invalid")]
	InvalidMint,
}
